<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">

  <link rel="preload" href="Human-001-00.png" as="image">
  <link rel="preload" href="Human-001-01.png" as="image">
  <link rel="preload" href="Human-001-02.png" as="image">

  <link rel="preload" href="Human-001-10.png" as="image">
  <link rel="preload" href="Human-001-11.png" as="image">
  <link rel="preload" href="Human-001-12.png" as="image">

  <link rel="preload" href="Human-001-20.png" as="image">
  <link rel="preload" href="Human-001-21.png" as="image">
  <link rel="preload" href="Human-001-22.png" as="image">

  <link rel="preload" href="Human-001-30.png" as="image">
  <link rel="preload" href="Human-001-31.png" as="image">
  <link rel="preload" href="Human-001-32.png" as="image">

  <link rel="preload" href="Hexagram-001.png" as="image">
  <link rel="preload" href="Hexagram-002.png" as="image">
  <link rel="preload" href="Hexagram-003.png" as="image">

  <link rel="preload" href="Dragon-001.png" as="image">
  <link rel="preload" href="Slime-001.png" as="image">
  <link rel="preload" href="Golem-001.png" as="image">
  <link rel="preload" href="Wizard-001.png" as="image">
  <link rel="preload" href="Python-001.png" as="image">

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width">
  <title>Roll Play</title>

  <script>
    window.onload = function () {
      PreloadMan();
    }
    function PreloadMan() {
      gnWebResourceDefective--;
      console.log(`gnWebResourceDefective: ${gnWebResourceDefective}`);
      if (!gnWebResourceDefective) {
        OnAllLady();
      }
    }
    preload = document.querySelectorAll('link[rel="preload"]');
    gnWebResourceDefective = preload.length + 1;
    for (let w of preload) {
      w.onload = PreloadMan;
    }

    gwHTMLHead = document.head;
    gwHTMLRoot = document.documentElement;
    goHTMLRoot_ComputedStyle = getComputedStyle(gwHTMLRoot);
    gnScreenWidth = screen.width;
    gnScreenHeight = screen.height;
    gnScreenMinimum = Math.min(gnScreenWidth, gnScreenHeight);
    gnScreenMaximum = Math.max(gnScreenWidth, gnScreenHeight);
    console.log('gnScreenWidth: ' + gnScreenWidth);
    console.log('gnScreenHeight: ' + gnScreenHeight);
    gnWindow_InnerWidth = window.innerWidth;
    gnWindow_InnerHeight = window.innerHeight;
    gnWindow_InnerMinimum = Math.min(gnWindow_InnerWidth, gnWindow_InnerHeight);
    gnWindow_InnerMaximum = Math.max(gnWindow_InnerWidth, gnWindow_InnerHeight);
    console.log('gnWindow_InnerWidth: ' + gnWindow_InnerWidth);
    console.log('gnWindow_InnerHeight: ' + gnWindow_InnerHeight);
    gwHTMLRoot.style.setProperty('--Window_InnerMinimum', gnWindow_InnerMinimum + 'px');
    CSSValue_Window_InnerMinimum = goHTMLRoot_ComputedStyle.getPropertyValue('--Window_InnerMinimum');
    console.log('CSSValue_Window_InnerMinimum: ' + CSSValue_Window_InnerMinimum);

  </script>
  <style>
    body {
      margin: 0;
    }

    .Border {
      border: solid thin #000;
    }

    .Container {
      display: grid;
      grid-template-columns: auto 1fr;
      column-gap: 1vw;
    }

    .CanvasStyle {
      /*
      display: inline-block;
      position: absolute;
      */
    }

  </style>
</head>
<body>
  <div class="Container">
    <canvas id="idCanvas" class="CanvasStyle"></canvas>
    <div id="idInformation" class="Border">
    </div>
  </div>

</body>
<script>
  function isObject(value) {
    return value !== null && typeof value === 'object'
  }

  class Figure_Bottom {
    size = 0;
    x = 0;
    y = 0;
    image;
    worth = 0;

    constructor(fimg, size, x, y) {
      this.setImage(fimg);
      this.setSize(size);
      this.setPos(x, y);
    }

    getImage1() {
      return this.image;
    }

    setImage(fimg) {
      let image;
      if (Array.isArray(fimg)) {
        this.image = new Array();
        for (let i = 0; i < fimg.length; i++) {
          if (Array.isArray(fimg)) {
            this.image[i] = new Array();
            for (let j = 0; j < fimg[i].length; j++) {
              image = new Image();
              image.src = fimg[i][j];
              this.image[i][j] = image;
            }
          } else {
            image = new Image();
            image.src = fimg[i];
            this.image[i] = image;
          }
        }
      } else if (fimg) {
        image = new Image();
        image.src = fimg;
        this.image = image;
      }
    }

    setRandomImage(fimg) {
      let fix = Math.floor(Math.random() * fimg.length);
      this.setImage(fimg[fix]);
    }

    setSize(size) {
      this.size = size;
    }

    setPos(x, y) {
      this.x = x;
      this.y = y;
    }

    getFBMX() {
      return this.x;
    }

    getFBMY() {
      return this.y;
    }

    getFBMSize() {
      return this.size;
    }

    getShielding() {
      return 0;
    }

    Move(dx, dy) {
      let x = this.x + dx;
      let y = this.y + dy;
      let sr = this.size / 2 - 1;
      let fbmmin = gnFieldBitMapMin;
      let fbmmax = gnFieldBitMapMax;
      if (fbmmin <= (x - sr) && (x + sr) <= fbmmax &&
        fbmmin <= (y - sr) && (y + sr) <= fbmmax) {
        this.setPos(x, y);
      }
    }

    DirectDraw(vex, vey, ves) {
      let image = this.getImage1();
      console.log(`image: ${image}; `);
      // goCtx2d.fillStyle = "#fff";
      // goCtx2d.fillRect(vex, vey, ves, ves);
      goCtx2d.drawImage(image, vex, vey, ves, ves);
      let sh = this.getShielding();
      if (0 < sh) {
        goCtx2d.fillStyle = "rgba(" + [0, 0, 0, sh] + ")";
        goCtx2d.fillRect(vex, vey, ves, ves);
      }
    }

    Draw() {
      let fbmx = this.getFBMX();
      let fbmy = this.getFBMY();
      let ves = this.size * gnViewEssenceScale;
      let vex = fbmx * gnViewEssenceScale - gnFECXBias - ves / 2;
      let vey = fbmy * gnViewEssenceScale - gnFECYBias - ves / 2;
      console.log(`vex: ${vex}; vey: ${vey}; ves: ${ves}; `);
      this.DirectDraw(vex, vey, ves);
      this.Information();
    }

    Conflict(oppo) {
      let cnf = false; // true; //
      // console.log(`★Conflict: oppo: ${oppo}; `);
      if (oppo) {
        let x0 = this.getFBMX();
        let y0 = this.getFBMY();
        let s0 = this.getFBMSize();
        let x1 = oppo.getFBMX();
        let y1 = oppo.getFBMY();
        let s1 = oppo.getFBMSize();
        /*
        console.log(`★Conflict: 
x0: ${x0}; y0: ${y0}; s0: ${s0}; 
x1: ${x1}; y1: ${y1}; s1: ${s1}; `);
*/
        // 矩形同士の当たり判定を行うには
        // http://mslabo.sakura.ne.jp/WordPress/make/processing%E3%80%80%E9%80%86%E5%BC%95%E3%81%8D%E3%83%AA%E3%83%95%E3%82%A1%E3%83%AC%E3%83%B3%E3%82%B9/%E7%9F%A9%E5%BD%A2%E5%90%8C%E5%A3%AB%E3%81%AE%E5%BD%93%E3%81%9F%E3%82%8A%E5%88%A4%E5%AE%9A%E3%82%92%E8%A1%8C%E3%81%86%E3%81%AB%E3%81%AF/
        // ABS( x1 – x2 ) <  ( aw + bw )/2 && ABS( y1 – y2 ) <  ( ah + bh )/2
        cnf = Math.abs(x0 - x1) < (s0 + s1) / 2
          && Math.abs(y0 - y1) < (s0 + s1) / 2;
      }
      return cnf;
    }

    Information() { }

    // setHP(hp) { }
    // KMove(keyCode) { }
  };

  class Figure_Spot extends Figure_Bottom {
    // FieldMap(x,y)
    core = 1;

    constructor(size, core) {
      let x, y;
      super(null, size, 0, 0,);
      this.worth = 1;
      this.core = core;
      x = Math.floor(gnFieldMapSize * Math.random());
      y = Math.floor(gnFieldMapSize * Math.random());
      // x = 0; y = 0;
      this.setPos(x, y);
      this.setRandomImage(["Hexagram-001.png", "Hexagram-002.png",]);
      console.log(`★Spot: this.x: ${this.x}; this.y: ${this.y};`);
    }

    setPos(x, y) {
      this.x = x;
      this.y = y;
      gd3nFieldMapArea[1][this.x][this.y] = this;
    }

    resetFieldMap() {
      gd3nFieldMapArea[1][this.x][this.y] = null;
    }

    getFBMX() {
      return this.x * gnFieldBlockSize + this.size / 2;
    }

    getFBMY() {
      return this.y * gnFieldBlockSize + this.size / 2;
    }

    getFBMSize() {
      return Math.ceil(this.size * this.core);
    }
  }

  class Figure_Worker extends Figure_Bottom {
    hp = 0;
    mp = 0;
    level = 0;

    setHP(hp) {
      this.hp = hp;
    }
  }

  class Figure_Enemy extends Figure_Worker {
    hpmax = 0;

    constructor(size, x, y) {
      super(null, size, x, y);
      this.setHP(4);
      this.worth = 0.0543;
      this.setRandomImage(["Dragon-001.png", "Slime-001.png",
        "Golem-001.png", "Python-001.png", "Wizard-001.png",]);
    }

    setHP(hp) {
      this.hpmax = hp;
      super.setHP(hp);
    }

    getShielding() {
      this.hp = 0 <= this.hp ? this.hp : 0;
      return (this.hpmax - this.hp) / this.hpmax;
    }

    Draw() {
      let vbmx = this.x;
      let vbmy = this.y;
      let ves = this.size * gnViewEssenceScale;
      let vex = vbmx * gnViewEssenceScale - ves / 2;
      let vey = vbmy * gnViewEssenceScale - ves / 2;
      console.log(`vex: ${vex}; vey: ${vey}; ves: ${ves}; `);
      this.DirectDraw(vex, vey, ves);
      // this.Information();
    }

    getFBMX() {
      throw 'This method is not supported!';
    }

    getFBMY() {
      throw 'This method is not supported!';
    }

  };

  class Figure_Walker extends Figure_Worker {
    direction = 0;
    walk = 0;
    feet = 3;

    constructor(fimg, size, x, y, hp, mp, level) {
      super(fimg, size, x, y);
      this.setHP(hp);
      this.mp = mp;
      this.level = level;
    }

    getImage1() {
      let idrc = this.image[this.direction];
      let image = idrc[Math.floor(this.walk / this.feet)];
      console.log(`image: ${image}; `);
      return image;
    }

    Information() {
      goInformation.innerText = `
名前：ラミー
ステータス
Level：${this.level}
HP：${this.hp}
MP：${this.mp}
      `;
    }

    KMove(keyCode) {
      if (gd2nMovKeySets[keyCode]) {
        console.log("★if (gd2nMovKeySets[keyCode])");
        let mov = gd2nMovKeySets[keyCode];
        let active = false; // true; //
        switch (keyCode) {
          case gd1nInpKeySets.down:
            active = true; // false; //
            this.direction = 0;
            break;
          case gd1nInpKeySets.left:
            active = true; // false; //
            this.direction = 1;
            break;
          case gd1nInpKeySets.up:
            active = true; // false; //
            this.direction = 2;
            break;
          case gd1nInpKeySets.right:
            active = true; // false; //
            this.direction = 3;
            break;
          default:
        }
        if (active) {
          console.log("★if (active)");
          this.Move(mov[0], mov[1]);
          let idrc = this.image[this.direction];
          this.walk++;
          this.walk = this.walk % (idrc.length * this.feet);
        }
      }
      if (gnFieldModeSets.disaster === gnFieldMode
        && 0.99 < Math.random()) {
        console.log("★if (gnFieldModeSets.disaster === gnFieldMode && 0.99 < Math.random())");
        if (!goFigure_Spot) {
          console.log("★★★ Spot ★★★");
          goFigure_Spot = new Figure_Spot(gnSpotModelSize, 0.7);
          console.log("★goFigure_Spot: " + goFigure_Spot);
        } else {
          console.log("★★★ Enemy ★★★");
          goFigure_Enemy = new Figure_Enemy(gnEnemyModelSize,
            gnViewBitMapRadius, gnViewBitMapRadius);
        }
      }
    }
  };

  class Resource {
  }

  goInformation = document.getElementById('idInformation');
  gnCanvasSize = gnWindow_InnerMinimum;
  goCanvas = document.getElementById('idCanvas');
  goCanvas.width = gnCanvasSize;
  goCanvas.height = gnCanvasSize;
  goCtx2d = goCanvas.getContext('2d');

  gnWalkStride = 8;
  gnCharModelSize = 32;
  gnSpotModelSize = 64;
  gnEnemyModelSize = 96;
  gnFieldBlockSize = 64;
  gnFieldMapSize = 50;
  gd1sFieldBlockPalette = ["#0f0", "#5b0", "#890", "#980", "#a70"];
  gnFieldBitMapSize = gnFieldMapSize * gnFieldBlockSize;
  gnLastSystemTime = Date.now();

  gnFieldModeSets = {
    safety: 0,
    normal: 1,
    disaster: 2,
    fight: 3,
  };
  gnFieldMode = gnFieldModeSets.safety;

  gnViewEssenceScale = gnScreenMaximum * 1.1 / 1000;
  console.log('gnViewEssenceScale: ' + gnViewEssenceScale);

  gnFieldMapMin = 0;
  gnFieldMapMax = gnFieldMapSize - 1;
  console.log('gnFieldMapMax: ' + gnFieldMapMax);
  gnFieldBitMapMin = 0;
  gnFieldBitMapMax = gnFieldMapSize * gnFieldBlockSize - 1;
  console.log('gnFieldBitMapMax: ' + gnFieldBitMapMax);
  gnFieldEssenceMin = 0;
  gnFieldEssenceMax = gnFieldBitMapMax * gnViewEssenceScale;
  console.log('gnFieldEssenceMax: ' + gnFieldEssenceMax);

  gnViewEssenceDiameter = gnCanvasSize;
  gnViewEssenceRadius = gnViewEssenceDiameter / 2;
  console.log('gnViewEssenceDiameter: ' + gnViewEssenceDiameter);
  console.log('gnViewEssenceRadius: ' + gnViewEssenceRadius);
  gnViewBitMapDiameter = gnCanvasSize / gnViewEssenceScale;
  gnViewBitMapRadius = gnViewBitMapDiameter / 2;
  console.log('gnViewBitMapRadius: ' + gnViewBitMapRadius);
  gnViewMapDiameter = gnViewBitMapDiameter / gnFieldBlockSize;
  gnViewMapRadius = gnViewMapDiameter / 2;
  console.log('gnViewMapRadius: ' + gnViewMapRadius);

  let side = 2;
  gd3nFieldMapArea = new Array(side);
  for (let k = 0; k < side; k++) {
    gd3nFieldMapArea[k] = new Array(gnFieldMapSize);
    for (let i = 0; i < gd3nFieldMapArea[k].length; i++) {
      gd3nFieldMapArea[k][i] = new Array(gnFieldMapSize);
      for (let j = 0; j < gd3nFieldMapArea[k][i].length; j++) {
        if (k === 0) {
          gd3nFieldMapArea[k][i][j] = Math.floor(Math.random() * gd1sFieldBlockPalette.length);
        }
      }
    }
  }

  gd1nInpKeySets = {
    left: 37,
    right: 39,
    down: 40,
    up: 38,
    space: 32,
  };

  gd2nMovKeySets = {
    37: [-gnWalkStride, 0], //left
    39: [gnWalkStride, 0], //right
    40: [0, gnWalkStride], //down
    38: [0, -gnWalkStride], //up
  };

  let goFigure_Walker = new Figure_Walker(
    [
      ["Human-001-00.png", "Human-001-01.png", "Human-001-02.png",],
      ["Human-001-10.png", "Human-001-11.png", "Human-001-12.png",],
      ["Human-001-20.png", "Human-001-21.png", "Human-001-22.png",],
      ["Human-001-30.png", "Human-001-31.png", "Human-001-32.png",],
    ],
    gnCharModelSize, gnFieldBitMapSize / 2, gnFieldBitMapSize / 2,
    30, 20, 1);

  let goFigure_Spot;
  let goFigure_Enemy;

  function OnAllLady() {
    FieldDraw(goFigure_Walker);
  }

  document.body.onkeydown = function (ev) {
    console.log('body.onkeydown = function (ev)');
    let time = Date.now();
    let scale = 1;
    let cm = goFigure_Walker;
    let worth = 0;
    if (20 < time - gnLastSystemTime) {
      if (goFigure_Enemy) {
        console.log('★if (goFigure_Enemy)');
        if (gd1nInpKeySets.space === ev.keyCode) {
          console.log('if (goFigure_Enemy && gd1nInpKeySets.space === ev.keyCode)');
          goFigure_Enemy.hp--;
          if (goFigure_Enemy.hp <= 0) {
            console.log('if (goFigure_Enemy.hp <= 0)');
            worth = goFigure_Enemy.worth;
            goFigure_Enemy = null;
          }
        }
      }
      if (!goFigure_Enemy) {
        console.log('★if (!goFigure_Enemy)');
        goFigure_Walker.KMove(ev.keyCode);
        goFigure_Walker.level += worth;
        goFigure_Walker.hp += worth;
        goFigure_Walker.mp += worth;
        if (goFigure_Walker.Conflict(goFigure_Spot)) {
          // console.log("★★★ Conflict ★★★");
          goFigure_Walker.level += goFigure_Spot.worth;
          goFigure_Spot.resetFieldMap();
          goFigure_Spot = null;
        }
      }
      FieldDraw(cm);
    }
    gnLastSystemTime = time;
  }

  function FieldDraw(oCharModel) {
    if (!gnWebResourceDefective) {
      let fbmcx = oCharModel.x;
      let fbmcy = oCharModel.y;

      let fmcx = fbmcx / gnFieldBlockSize;
      let fmcy = fbmcy / gnFieldBlockSize;
      let vecx = fbmcx * gnViewEssenceScale;
      let vecy = fbmcy * gnViewEssenceScale;

      let fmcxmin = fmcx - gnViewMapRadius;
      let fmcxmax = fmcx + gnViewMapRadius;
      let fmcymin = fmcy - gnViewMapRadius;
      let fmcymax = fmcy + gnViewMapRadius;

      let fbmcxmin = 0;
      let fbmcymin = 0;
      gnFieldMode = gnFieldModeSets.disaster

      let fmcxbias = fmcxmin;
      let fbmcxbias = fmcxbias * gnFieldBlockSize;
      fmcxmin = 0 <= fmcxmin ? Math.floor(fmcxmin) : fmcxmin;
      fmcxmax = 0 <= fmcxmax ? Math.ceil(fmcxmax) : 0;
      console.log(`(1): fmcxbias: ${fmcxbias}; fbmcxbias: ${fbmcxbias}; `);
      console.log(`(1): fmcxmin: ${fmcxmin}; fmcxmax: ${fmcxmax}; `);
      if (fmcxmin < 0) {
        // gnFieldMode = gnFieldModeSets.safety;
        fmcxmin = 0;
        fmcxmax = Math.ceil(gnCanvasSize / gnFieldBlockSize);
        fbmcxbias = 0;
      }
      if (gnFieldMapSize < fmcxmax) {
        // gnFieldMode = gnFieldModeSets.safety;
        fmcxmax = gnFieldMapSize - 1;
        fbmcxmin = fmcxmax * gnFieldBlockSize - gnCanvasSize;
        fmcxmin = fbmcxmin / gnFieldBlockSize;
        // fmcxbias = gnPrevFMCXBias;
        fmcxbias = gnFieldMapSize - (gnViewBitMapDiameter / gnFieldBlockSize);
        fbmcxbias = fmcxbias * gnFieldBlockSize;
        fmcxmin = 0 <= fmcxmin ? Math.floor(fmcxmin) : 0;
      } else {
        gnPrevFMCXBias = fmcxbias;
      }
      let fecxbias = fbmcxbias * gnViewEssenceScale;
      console.log(`(2): fmcxbias: ${fmcxbias}; fbmcxbias: ${fbmcxbias}; `);
      console.log(`(2): fmcxmin: ${fmcxmin}; fmcxmax: ${fmcxmax}; `);
      console.log(`fecxbias: ${fecxbias}`);

      let fmcybias = fmcymin;
      let fbmcybias = fmcybias * gnFieldBlockSize;
      fmcymin = 0 <= fmcymin ? Math.floor(fmcymin) : fmcymin;
      fmcymax = 0 <= fmcymax ? Math.ceil(fmcymax) : 0;
      console.log(`(1): fmcybias: ${fmcybias}; fbmcybias: ${fbmcybias}; `);
      console.log(`(1): fmcymin: ${fmcymin}; fmcymax: ${fmcymax}; `);
      if (fmcymin < 0) {
        // gnFieldMode = gnFieldModeSets.safety;
        fmcymin = 0;
        fmcymax = Math.ceil(gnCanvasSize / gnFieldBlockSize);
        fbmcybias = 0;
      }
      if (gnFieldMapSize < fmcymax) {
        // gnFieldMode = gnFieldModeSets.safety;
        fmcymax = gnFieldMapSize - 1;
        fbmcymin = fmcymax * gnFieldBlockSize - gnCanvasSize;
        fmcymin = fbmcymin / gnFieldBlockSize;
        // fmcybias = gnPrevFMCYBias;
        fmcybias = gnFieldMapSize - (gnViewBitMapDiameter / gnFieldBlockSize);
        fbmcybias = fmcybias * gnFieldBlockSize;
        fmcymin = 0 <= fmcymin ? Math.floor(fmcymin) : 0;
      } else {
        gnPrevFMCYBias = fmcybias;
      }
      let fecybias = fbmcybias * gnViewEssenceScale;
      console.log(`(2): fmcybias: ${fmcybias}; fbmcybias: ${fbmcybias}; `);
      console.log(`(2): fmcymin: ${fmcymin}; fmcymax: ${fmcymax}; `);
      console.log(`fecybias: ${fecybias}`);

      gnFECXBias = fecxbias;
      gnFECYBias = fecybias;
      let fbmcbx = fbmcx - fmcxmin * gnFieldBlockSize;
      let fbmcby = fbmcy - fmcymin * gnFieldBlockSize;

      let fecbx = fbmcbx * gnViewEssenceScale;
      let fecby = fbmcby * gnViewEssenceScale;
      console.log(`fmcxmin: ${fmcxmin}; fmcxmax: ${fmcxmax}; `);
      console.log(`fmcymin: ${fmcymin}; fmcymax: ${fmcymax}; `);

      let thick = fmcxmax - fmcxmin;
      goCtx2d.fillStyle = "#000";
      goCtx2d.fillRect(0, 0, gnCanvasSize, gnCanvasSize);
      if (!goFigure_Enemy) {
        if (Math.ceil(gnViewMapDiameter) + 1 < thick) {
          console.log("Error(Math.ceil(gnViewMapDiameter) + 1 < thick)");
          // console.log(`gnViewMapDiameter: ${gnViewMapDiameter}; `);
          console.log(`thick: ${thick}; `);
        }
        for (let x = fmcxmin; x <= fmcxmax; x++) {
          thick = fmcymax - fmcymin;
          if (Math.ceil(gnViewMapDiameter) + 1 < thick) {
            console.log("Error(Math.ceil(gnViewMapDiameter) + 1 < thick)");
            console.log(`thick: ${thick}; `);
          }
          let xl = gd3nFieldMapArea[0].length;
          if (0 <= x && x < xl) {
            for (let y = fmcymin; y <= fmcymax; y++) {
              let yl = gd3nFieldMapArea[0][x].length;
              if (0 <= y && y < yl) {
                // console.log(`x: ${x}; y: ${y}; `);
                let vbmx = x * gnFieldBlockSize;
                let vbmy = y * gnFieldBlockSize;
                let vex = vbmx * gnViewEssenceScale - fecxbias;
                let vey = vbmy * gnViewEssenceScale - fecybias;
                let ves = gnFieldBlockSize * gnViewEssenceScale;
                goCtx2d.fillStyle =
                  gd1sFieldBlockPalette[gd3nFieldMapArea[0][x][y]];
                goCtx2d.fillRect(vex, vey, ves, ves);
                let fs = gd3nFieldMapArea[1][x][y];
                if (fs) {
                  fs.Draw();
                }
              }
            }
          }
        }
        oCharModel.Draw();
      } else {
        goFigure_Enemy.Draw();
        // goFigure_Enemy = null;
      }
    }
  }

</script>
</html>
